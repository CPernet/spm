function meeg = spm_cfg_meeg
% SPM Configuration file
% automatically generated by the MATLABBATCH utility function GENCODE
%_______________________________________________________________________
% Copyright (C) 2008 Wellcome Trust Centre for Neuroimaging

% $Id: spm_cfg_meeg.m 1185 2008-03-04 16:31:21Z volkmar $

% ---------------------------------------------------------------------
% dataset Select the dataset file
% ---------------------------------------------------------------------
dataset         = cfg_files;
dataset.tag     = 'dataset';
dataset.name    = 'Select the dataset file';
dataset.help    = {'Select the data file'};
dataset.filter = '*';
dataset.ufilter = '.*';
dataset.num     = [1 1];
% ---------------------------------------------------------------------
% eventtype Event type
% ---------------------------------------------------------------------
eventtype         = cfg_entry;
eventtype.tag     = 'eventtype';
eventtype.name    = 'Event type';
eventtype.val = {'gui'};
eventtype.help    = {'Type of the event for trial selection'};
eventtype.strtype = 's';
eventtype.num     = [1 1];
% ---------------------------------------------------------------------
% eventvalue Event value
% ---------------------------------------------------------------------
eventvalue         = cfg_entry;
eventvalue.tag     = 'eventvalue';
eventvalue.name    = 'Event value';
eventvalue.val = {'gui'};
eventvalue.help    = {'Value of the event for trial selection'};
eventvalue.strtype = 's';
eventvalue.num     = [1 1];
% ---------------------------------------------------------------------
% prestim Pre-trigger time
% ---------------------------------------------------------------------
prestim         = cfg_entry;
prestim.tag     = 'prestim';
prestim.name    = 'Pre-trigger time';
prestim.help    = {'Pre-trigger latency in seconds'};
prestim.strtype = 'r';
prestim.num     = [1 1];
% ---------------------------------------------------------------------
% poststim Post-trigger time
% ---------------------------------------------------------------------
poststim         = cfg_entry;
poststim.tag     = 'poststim';
poststim.name    = 'Post-trigger time';
poststim.help    = {'Post-trigger latency in seconds'};
poststim.strtype = 'r';
poststim.num     = [1 1];
% ---------------------------------------------------------------------
% ignorelim Ignore trial limits in the data
% ---------------------------------------------------------------------
ignorelim         = cfg_menu;
ignorelim.tag     = 'ignorelim';
ignorelim.name    = 'Ignore trial limits in the data';
ignorelim.val = {'no'};
ignorelim.help    = {
                     'In some file formats there can be events that already '
                     'contain information about the trial limits. If such event'
                     'is chosen SPM will disregard the user defined pre- and post-'
                     'stimulus times. Choose ''yes'' in this menu to override this'
                     'default behavior and ignore the information from the file.'
                     'Leave it as ''no'' unless you know well what you are doing.'
}';
ignorelim.labels = {
                    'Yes'
                    'No'
}';
ignorelim.values = {
                    'yes'
                    'no'
}';
% ---------------------------------------------------------------------
% savetrl Save TRL to file
% ---------------------------------------------------------------------
savetrl         = cfg_menu;
savetrl.tag     = 'savetrl';
savetrl.name    = 'Save TRL to file';
savetrl.val = {'no'};
savetrl.help    = {'Choose whether to save the TRL matrix to a mat or ASCII file'};
savetrl.labels = {
                  'Yes'
                  'No'
}';
savetrl.values = {
                  'yes'
                  'no'
}';
% ---------------------------------------------------------------------
% sub_trialdef Define based on events
% ---------------------------------------------------------------------
sub_trialdef         = cfg_branch;
sub_trialdef.tag     = 'sub_trialdef';
sub_trialdef.name    = 'Define based on events';
sub_trialdef.val     = { eventtype eventvalue prestim poststim ignorelim savetrl};
% ---------------------------------------------------------------------
% trlfile Define by TRL file
% ---------------------------------------------------------------------
trlfile         = cfg_files;
trlfile.tag     = 'trlfile';
trlfile.name    = 'Define by TRL file';
trlfile.help    = {'Select an ASCII or matlab file with TRL structure (see definitrial() help)'};
trlfile.filter = '*';
trlfile.ufilter = '.*';
trlfile.num     = [1 1];
% ---------------------------------------------------------------------
% loadcont Load continuous data
% ---------------------------------------------------------------------
loadcont         = cfg_const;
loadcont.tag     = 'loadcont';
loadcont.name    = 'Load continuous data';
loadcont.val = {' '};
loadcont.help    = {'Load continuous data without epoching.'};
% ---------------------------------------------------------------------
% eventtype Event type
% ---------------------------------------------------------------------
eventtype         = cfg_entry;
eventtype.tag     = 'eventtype';
eventtype.name    = 'Event type';
eventtype.val = {'gui'};
eventtype.help    = {'Type of the event for trial selection'};
eventtype.strtype = 's';
eventtype.num     = [1 1];
% ---------------------------------------------------------------------
% eventvalue Event value
% ---------------------------------------------------------------------
eventvalue         = cfg_entry;
eventvalue.tag     = 'eventvalue';
eventvalue.name    = 'Event value';
eventvalue.val = {'gui'};
eventvalue.help    = {'Value of the event for trial selection'};
eventvalue.strtype = 's';
eventvalue.num     = [1 1];
% ---------------------------------------------------------------------
% prestim Pre-trigger time
% ---------------------------------------------------------------------
prestim         = cfg_entry;
prestim.tag     = 'prestim';
prestim.name    = 'Pre-trigger time';
prestim.help    = {'Pre-trigger latency in seconds'};
prestim.strtype = 'r';
prestim.num     = [1 1];
% ---------------------------------------------------------------------
% poststim Post-trigger time
% ---------------------------------------------------------------------
poststim         = cfg_entry;
poststim.tag     = 'poststim';
poststim.name    = 'Post-trigger time';
poststim.help    = {'Post-trigger latency in seconds'};
poststim.strtype = 'r';
poststim.num     = [1 1];
% ---------------------------------------------------------------------
% ignorelim Ignore trial limits in the data
% ---------------------------------------------------------------------
ignorelim         = cfg_menu;
ignorelim.tag     = 'ignorelim';
ignorelim.name    = 'Ignore trial limits in the data';
ignorelim.val = {'no'};
ignorelim.help    = {
                     'In some file formats there can be events that already '
                     'contain information about the trial limits. If such event'
                     'is chosen SPM will disregard the user defined pre- and post-'
                     'stimulus times. Choose ''yes'' in this menu to override this'
                     'default behavior and ignore the information from the file.'
                     'Leave it as ''no'' unless you know well what you are doing.'
}';
ignorelim.labels = {
                    'Yes'
                    'No'
}';
ignorelim.values = {
                    'yes'
                    'no'
}';
% ---------------------------------------------------------------------
% savetrl Save TRL to file
% ---------------------------------------------------------------------
savetrl         = cfg_menu;
savetrl.tag     = 'savetrl';
savetrl.name    = 'Save TRL to file';
savetrl.val = {'no'};
savetrl.help    = {'Choose whether to save the TRL matrix to a mat or ASCII file'};
savetrl.labels = {
                  'Yes'
                  'No'
}';
savetrl.values = {
                  'yes'
                  'no'
}';
% ---------------------------------------------------------------------
% sub_trialdef Define based on events
% ---------------------------------------------------------------------
sub_trialdef         = cfg_branch;
sub_trialdef.tag     = 'sub_trialdef';
sub_trialdef.name    = 'Define based on events';
sub_trialdef.val     = { eventtype eventvalue prestim poststim ignorelim savetrl};
% ---------------------------------------------------------------------
% trials Trial definitions
% ---------------------------------------------------------------------
trials         = cfg_choice;
trials.tag     = 'trials';
trials.name    = 'Trial definitions';
trials.val     = { sub_trialdef};
trials.help    = {
                  'Choose whether to define trials semi-automatically based on events in the file'
                  'or using iser defined trl matrix (see definitrial() help)'
}';
trials.values  = { sub_trialdef trlfile loadcont};
% ---------------------------------------------------------------------
% padding Padding for filtering
% ---------------------------------------------------------------------
padding         = cfg_entry;
padding.tag     = 'padding';
padding.name    = 'Padding for filtering';
padding.val{1} = double(0);
padding.help    = {'Length (in sec) to which the trials should be padded for filtering'};
padding.strtype = 'r';
padding.num     = [1 1];
% ---------------------------------------------------------------------
% timeshift Shift time axis
% ---------------------------------------------------------------------
timeshift         = cfg_entry;
timeshift.tag     = 'timeshift';
timeshift.name    = 'Shift time axis';
timeshift.val{1} = double(0);
timeshift.help    = {'Set the zero of the time axis to this value (relatively to the trigger)'};
timeshift.strtype = 'r';
timeshift.num     = [1 1];
% ---------------------------------------------------------------------
% forcecont Force treating data as continuous
% ---------------------------------------------------------------------
forcecont         = cfg_menu;
forcecont.tag     = 'forcecont';
forcecont.name    = 'Force treating data as continuous';
forcecont.val = {'no'};
forcecont.help    = {'Force preprocessing to read across trial borders.'};
forcecont.labels = {
                    'Yes'
                    'No'
}';
forcecont.values = {
                    'yes'
                    'no'
}';
% ---------------------------------------------------------------------
% channel Select channels
% ---------------------------------------------------------------------
channel         = cfg_entry;
channel.tag     = 'channel';
channel.name    = 'Select channels';
channel.val = {'all'};
channel.help    = {
                   '''gui''     a graphical user interface will pop up to select the channels'
                   '''all''     is replaced by all channels in the datafile'
                   '''MEG''     is replaced by all channels in the CTF datafile starting with ''M'''
                   '''EEG''     is replaced by all channels in the CTF datafile starting with  ''EEG'''
                   '''EEG1020'' is replaced by ''Fp1'', ''Fpz'', ''Fp2'', ''F7'', ''F3'','
                   '''EOG''     is replaced by all recognized EOG channels'
                   '''EMG''     is replaced by all channels in the datafile starting with ''EMG'''
                   '''lfp''     is replaced by all channels in the datafile starting with ''lfp'''
                   '''mua''     is replaced by all channels in the datafile starting with ''mua'''
                   '''spike''   is replaced by all channels in the datafile starting with ''spike'''
                   ' 10      is replaced by the 10th channel in the datafile'
                   'Other channel groups are'
                   '''EEG1010''    with approximately 90 electrodes'
                   '''EEG1005''    with approximately 350 electrodes'
                   '''EEGCHWILLA'' for Dorothee Chwilla''s electrode caps (used at the NICI)'
                   '''EEGBHAM''    for the 128 channel EEG system used in Birmingham'
                   '''EEGREF''     for mastoid and ear electrodes (M1, M2, LM, RM, A1, A2)'
                   '''MZ''         for MEG central'
                   '''ML''         for MEG left'
                   '''MR''         for MEG right'
                   '''MLx'', ''MRx'' and ''MZx'' with x=C,F,O,P,T for left/right central, frontal, occipital, parietal and temporal'
                   'You can also exclude channels or channel groups using the following syntax'
                   '{''all'', ''-POz'', ''-Fp1'', ''-EOG''}'
}';
channel.strtype = 's';
channel.num     = [1 1];
% ---------------------------------------------------------------------
% lpfreq LP frequency
% ---------------------------------------------------------------------
lpfreq         = cfg_entry;
lpfreq.tag     = 'lpfreq';
lpfreq.name    = 'LP frequency';
lpfreq.help    = {'Lowpass  frequency in Hz'};
lpfreq.strtype = 'r';
lpfreq.num     = [1 1];
% ---------------------------------------------------------------------
% lpfiltord LP order
% ---------------------------------------------------------------------
lpfiltord         = cfg_entry;
lpfiltord.tag     = 'lpfiltord';
lpfiltord.name    = 'LP order';
lpfiltord.val{1} = double(6);
lpfiltord.help    = {'Lowpass  filter order'};
lpfiltord.strtype = 'n';
lpfiltord.num     = [1 1];
% ---------------------------------------------------------------------
% lpfilttype LP filter type
% ---------------------------------------------------------------------
lpfilttype         = cfg_menu;
lpfilttype.tag     = 'lpfilttype';
lpfilttype.name    = 'LP filter type';
lpfilttype.val = {'but'};
lpfilttype.help    = {'Type of the lowpass filter'};
lpfilttype.labels = {
                     'Butterworth'
                     'FIR'
}';
lpfilttype.values = {
                     'but'
                     'fir'
}';
% ---------------------------------------------------------------------
% lpfiltdir LP filter direction
% ---------------------------------------------------------------------
lpfiltdir         = cfg_menu;
lpfiltdir.tag     = 'lpfiltdir';
lpfiltdir.name    = 'LP filter direction';
lpfiltdir.val = {'twopass'};
lpfiltdir.help    = {'Direction of the lowpass filter'};
lpfiltdir.labels = {
                    'zero phase'
                    'forward'
                    'backward'
}';
lpfiltdir.values = {
                    'twopass'
                    'onepass'
                    'onepass-reverse'
}';
% ---------------------------------------------------------------------
% lpfilter Lowpass filter
% ---------------------------------------------------------------------
lpfilter         = cfg_branch;
lpfilter.tag     = 'lpfilter';
lpfilter.name    = 'Lowpass filter';
lpfilter.val     = { lpfreq lpfiltord lpfilttype lpfiltdir};
lpfilter.help    = {'Should a lowpass filter be used'};
% ---------------------------------------------------------------------
% hpfreq HP frequency
% ---------------------------------------------------------------------
hpfreq         = cfg_entry;
hpfreq.tag     = 'hpfreq';
hpfreq.name    = 'HP frequency';
hpfreq.help    = {'Highpass  frequency in Hz'};
hpfreq.strtype = 'r';
hpfreq.num     = [1 1];
% ---------------------------------------------------------------------
% hpfiltord HP order
% ---------------------------------------------------------------------
hpfiltord         = cfg_entry;
hpfiltord.tag     = 'hpfiltord';
hpfiltord.name    = 'HP order';
hpfiltord.val{1} = double(6);
hpfiltord.help    = {'Highpass  filter order'};
hpfiltord.strtype = 'n';
hpfiltord.num     = [1 1];
% ---------------------------------------------------------------------
% hpfilttype HP filter type
% ---------------------------------------------------------------------
hpfilttype         = cfg_menu;
hpfilttype.tag     = 'hpfilttype';
hpfilttype.name    = 'HP filter type';
hpfilttype.val = {'but'};
hpfilttype.help    = {'Type of the highpass filter'};
hpfilttype.labels = {
                     'Butterworth'
                     'FIR'
}';
hpfilttype.values = {
                     'but'
                     'fir'
}';
% ---------------------------------------------------------------------
% hpfiltdir HP filter direction
% ---------------------------------------------------------------------
hpfiltdir         = cfg_menu;
hpfiltdir.tag     = 'hpfiltdir';
hpfiltdir.name    = 'HP filter direction';
hpfiltdir.val = {'twopass'};
hpfiltdir.help    = {'Direction of the highpass filter'};
hpfiltdir.labels = {
                    'zero phase'
                    'forward'
                    'backward'
}';
hpfiltdir.values = {
                    'twopass'
                    'onepass'
                    'onepass-reverse'
}';
% ---------------------------------------------------------------------
% hpfilter Highpass filter
% ---------------------------------------------------------------------
hpfilter         = cfg_branch;
hpfilter.tag     = 'hpfilter';
hpfilter.name    = 'Highpass filter';
hpfilter.val     = { hpfreq hpfiltord hpfilttype hpfiltdir};
hpfilter.help    = {'Should a highpass filter be used'};
% ---------------------------------------------------------------------
% bpfreq BP frequency
% ---------------------------------------------------------------------
bpfreq         = cfg_entry;
bpfreq.tag     = 'bpfreq';
bpfreq.name    = 'BP frequency';
bpfreq.help    = {'Bandpass  frequency in Hz'};
bpfreq.strtype = 'r';
bpfreq.num     = [1 2];
% ---------------------------------------------------------------------
% bpfiltord BP order
% ---------------------------------------------------------------------
bpfiltord         = cfg_entry;
bpfiltord.tag     = 'bpfiltord';
bpfiltord.name    = 'BP order';
bpfiltord.val{1} = double(4);
bpfiltord.help    = {'Bandpass filter order'};
bpfiltord.strtype = 'n';
bpfiltord.num     = [1 1];
% ---------------------------------------------------------------------
% bpfilttype BP filter type
% ---------------------------------------------------------------------
bpfilttype         = cfg_menu;
bpfilttype.tag     = 'bpfilttype';
bpfilttype.name    = 'BP filter type';
bpfilttype.val = {'but'};
bpfilttype.help    = {'Type of the bandpass filter'};
bpfilttype.labels = {
                     'Butterworth'
                     'FIR'
}';
bpfilttype.values = {
                     'but'
                     'fir'
}';
% ---------------------------------------------------------------------
% bpfiltdir BP filter direction
% ---------------------------------------------------------------------
bpfiltdir         = cfg_menu;
bpfiltdir.tag     = 'bpfiltdir';
bpfiltdir.name    = 'BP filter direction';
bpfiltdir.val = {'twopass'};
bpfiltdir.help    = {'Direction of the bandpass filter'};
bpfiltdir.labels = {
                    'zero phase'
                    'forward'
                    'backward'
}';
bpfiltdir.values = {
                    'twopass'
                    'onepass'
                    'onepass-reverse'
}';
% ---------------------------------------------------------------------
% bpfilter Bandpass filter
% ---------------------------------------------------------------------
bpfilter         = cfg_branch;
bpfilter.tag     = 'bpfilter';
bpfilter.name    = 'Bandpass filter';
bpfilter.val     = { bpfreq bpfiltord bpfilttype bpfiltdir};
bpfilter.help    = {'Should a bandpass filter be used'};
% ---------------------------------------------------------------------
% lnfreq Notch frequency
% ---------------------------------------------------------------------
lnfreq         = cfg_entry;
lnfreq.tag     = 'lnfreq';
lnfreq.name    = 'Notch frequency';
lnfreq.val{1} = double(50);
lnfreq.help    = {'Notch  frequency in Hz'};
lnfreq.strtype = 'r';
lnfreq.num     = [1 1];
% ---------------------------------------------------------------------
% lnfiltord Notch filter order
% ---------------------------------------------------------------------
lnfiltord         = cfg_entry;
lnfiltord.tag     = 'lnfiltord';
lnfiltord.name    = 'Notch filter order';
lnfiltord.val{1} = double(4);
lnfiltord.help    = {'Notch  filter order'};
lnfiltord.strtype = 'n';
lnfiltord.num     = [1 1];
% ---------------------------------------------------------------------
% lnfilter Line noise filter
% ---------------------------------------------------------------------
lnfilter         = cfg_branch;
lnfilter.tag     = 'lnfilter';
lnfilter.name    = 'Line noise filter';
lnfilter.val     = { lnfreq lnfiltord};
lnfilter.help    = {'Should a notch filter be used'};
% ---------------------------------------------------------------------
% dftfreq DFT frequencies
% ---------------------------------------------------------------------
dftfreq         = cfg_entry;
dftfreq.tag     = 'dftfreq';
dftfreq.name    = 'DFT frequencies';
dftfreq.val{1} = double([50 100 150]);
dftfreq.help    = {'Line noise and harmonics  frequencies in Hz'};
dftfreq.strtype = 'r';
dftfreq.num     = [1 3];
% ---------------------------------------------------------------------
% dftfilter DFT filter
% ---------------------------------------------------------------------
dftfilter         = cfg_branch;
dftfilter.tag     = 'dftfilter';
dftfilter.name    = 'DFT filter';
dftfilter.val     = { dftfreq};
dftfilter.help    = {'Should a DFT filter be used'};
% ---------------------------------------------------------------------
% medianfiltord Median filter order
% ---------------------------------------------------------------------
medianfiltord         = cfg_entry;
medianfiltord.tag     = 'medianfiltord';
medianfiltord.name    = 'Median filter order';
medianfiltord.val{1} = double(9);
medianfiltord.help    = {'Median filter order'};
medianfiltord.strtype = 'n';
medianfiltord.num     = [1 1];
% ---------------------------------------------------------------------
% medianfilter Median Filter
% ---------------------------------------------------------------------
medianfilter         = cfg_branch;
medianfilter.tag     = 'medianfilter';
medianfilter.name    = 'Median Filter';
medianfilter.val     = { medianfiltord};
% ---------------------------------------------------------------------
% detrend Detrend
% ---------------------------------------------------------------------
detrend         = cfg_const;
detrend.tag     = 'detrend';
detrend.name    = 'Detrend';
detrend.val = {'yes'};
detrend.help    = {'Detrend the data'};
% ---------------------------------------------------------------------
% blcwindow Baseline window
% ---------------------------------------------------------------------
blcwindow         = cfg_entry;
blcwindow.tag     = 'blcwindow';
blcwindow.name    = 'Baseline window';
blcwindow.help    = {'[begin end] in seconds, the default is the complete trial'};
blcwindow.strtype = 'r';
blcwindow.num     = [1 2];
% ---------------------------------------------------------------------
% blc Baseline correction
% ---------------------------------------------------------------------
blc         = cfg_branch;
blc.tag     = 'blc';
blc.name    = 'Baseline correction';
blc.val     = { blcwindow};
% ---------------------------------------------------------------------
% hilbert Hilbert transform
% ---------------------------------------------------------------------
hilbert         = cfg_const;
hilbert.tag     = 'hilbert';
hilbert.name    = 'Hilbert transform';
hilbert.val = {'yes'};
hilbert.help    = {'Use Hilbert transform'};
% ---------------------------------------------------------------------
% rectify Rectify data
% ---------------------------------------------------------------------
rectify         = cfg_const;
rectify.tag     = 'rectify';
rectify.name    = 'Rectify data';
rectify.val = {'yes'};
rectify.help    = {'Rectify the data'};
% ---------------------------------------------------------------------
% filters Filters and transformations
% ---------------------------------------------------------------------
filters         = cfg_repeat;
filters.tag     = 'filters';
filters.name    = 'Filters and transformations';
filters.values  = { lpfilter hpfilter bpfilter lnfilter dftfilter medianfilter detrend blc hilbert rectify};
filters.check   = @check_filter;
filters.num     = [0 Inf];
% ---------------------------------------------------------------------
% chansubset Channel subset
% ---------------------------------------------------------------------
chansubset         = cfg_branch;
chansubset.tag     = 'chansubset';
chansubset.name    = 'Channel subset';
chansubset.val     = { channel filters};
% ---------------------------------------------------------------------
% generic Channels
% ---------------------------------------------------------------------
generic         = cfg_repeat;
generic.tag     = 'generic';
generic.name    = 'Channels';
generic.values  = { chansubset};
generic.num     = [0 Inf];
% ---------------------------------------------------------------------
% precision Number precision
% ---------------------------------------------------------------------
precision         = cfg_menu;
precision.tag     = 'precision';
precision.name    = 'Number precision';
precision.val = {'double'};
precision.help    = {'Number precision for data processing'};
precision.labels = {
                    'Single'
                    'Double'
}';
precision.values = {
                    'single'
                    'double'
}';
% ---------------------------------------------------------------------
% savename Name of the output file
% ---------------------------------------------------------------------
savename         = cfg_entry;
savename.tag     = 'savename';
savename.name    = 'Name of the output file';
savename.help    = {'Name of the file in which the data will be saved.'};
savename.strtype = 's';
savename.num     = [1 1];
% ---------------------------------------------------------------------
% ctf Name of the channel template file
% ---------------------------------------------------------------------
ctf         = cfg_files;
ctf.tag     = 'ctf';
ctf.name    = 'Name of the channel template file';
ctf.val{1} = {'empty.mat'};
ctf.help    = {'Select the channel template file (if available)'};
ctf.filter = 'mat';
ctf.dir = '/export/toolbox/spm/trunk/EEGtemplates';
ctf.ufilter = '.*';
ctf.num     = [1 1];
% ---------------------------------------------------------------------
% sub_savesettings Save settings
% ---------------------------------------------------------------------
sub_savesettings         = cfg_branch;
sub_savesettings.tag     = 'sub_savesettings';
sub_savesettings.name    = 'Save settings';
sub_savesettings.val     = { savename ctf};
% ---------------------------------------------------------------------
% meeg MEEG Preprocessing
% ---------------------------------------------------------------------
meeg         = cfg_exbranch;
meeg.tag     = 'meeg';
meeg.name    = 'MEEG Preprocessing';
meeg.val     = { dataset trials padding timeshift forcecont generic precision sub_savesettings};
meeg.help    = {'Preprocessing of MEG/EEG data'};
meeg.prog = @meeg_preprocess;
meeg.modality = {'EEG'};
%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% SUBFUNCTION runs the Fieldtrip preprocessing based on the config tree
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

function meeg_preprocess(S)

addpath(fullfile(spm('dir'), 'MEEGpreprocessing'), ...
    fullfile(spm('dir'), 'MEEGfileio'));

cfg.dataset=cell2mat(S.dataset);

switch cell2mat(fieldnames(S.trials))
    case 'sub_trialdef'
        cfg.trialdef=jobtree2cfg(S.trials.sub_trialdef);
        % In case the event value is numeric tries to convert it into a number
        try cfg.trialdef.eventvalue=str2num(cfg.trialdef.eventvalue); catch end
        trl=trialfun_spm(cfg);
        cfg.timeshift = S.timeshift;
    case 'trlfile'
        trl=load(cell2mat(S.trials.trlfile));
        if isstruct(trl)
            trl=trl.trl;
        end
        if size(trl, 2)<3
            error('TRL matrix should have at least 3 columns');
        elseif size(trl, 2)==3
            warning('For SPM the fourth column of TRL matrix should contain event codes. Adding 1s');
            trl=[trl ones(size(trl,1), 1)];
        end

        cfg.timeshift = S.timeshift;
    case 'loadcont'
        cfg.trialdef.triallength = Inf;
        cfg.trialdef.ntrials = 1;
        trl=trialfun_spm(cfg);
        cfg.event = read_event(cfg.dataset);

        cfg.timeshift = 0;
end
cfg.trl=trl;


cfg.precision=S.precision;

cfg.padding=S.padding;

cfg.forcecont=strcmpi(S.forcecont, 'yes');

% Runs separate preprocessing for different channel groups
data={};
for ind= 1:length(S.chansubset)
    if iscell(S.chansubset(ind))
        chansettings=S.chansubset{ind};
    else
        chansettings=S.chansubset(ind);
    end

    cfg1=cfg;
    cfg1.channel=tokenize(chansettings.channel, ' ');

    for ind2=1:length(chansettings.filters)
        cfg1=mergestruct(cfg1, jobtree2cfg(chansettings.filters{ind2}));

        % This is to add 'yes' for the filter settings that appear in the
        % cfg tree
        cfg1=setfield(cfg1, cell2mat(fieldnames(chansettings.filters{ind2})), 'yes');
    end

    data{ind} = spm_eeg_preprocessing(cfg1);
end

if length(data)>1
    data=ft_appenddata([], data{:});
else
    data=data{1};
end

data.cfg.trl = trl;

[junk, ctfname] = fileparts(S.sub_savesettings.ctf{:});

ft2spm(data, S.sub_savesettings.savename, [ctfname '.mat']);


%%

function cfg=jobtree2cfg(jobtree)
% Converts the GUI tree to FT cfg struct
fields_list=fieldnames(jobtree);
cfg=[];
for ind =1:length(fields_list)
    if isstruct(getfield(jobtree, fields_list{ind}))
        % If there is a substruct in the tree calls itself recursively
        subcfg=jobtree2cfg(getfield(jobtree, fields_list{ind}));
        if  strncmp(fields_list{ind}, 'sub_', 4)
            % This makes it possible to keep substructs in the cfg
            % if their names are preceded by sub_ prefix
            cfg=setfield(cfg, fields_list{ind}(5:end), subcfg);
        else
            cfg=mergestruct(cfg, subcfg);
        end
    else
        value=getfield(jobtree, fields_list{ind});
        if iscell(value)
            if length(value)>1
                for ind2=1:length(value)
                    cfg=mergestruct(cfg, jobtree2cfg(value{ind2}));
                end
            else
                if ~isempty(value)
                    value=value{:};
                end
                cfg=setfield(cfg, fields_list{ind}, value);
            end
        else
            cfg=setfield(cfg, fields_list{ind}, value);
        end
    end
end


function str = check_filter(job)
fields={};
for n=1:length(job)
    fields=[fields fieldnames(job{n})];
end
if length(fields)~=length(unique(fields));
    str = 'Only one instance of each transformation is allowed.';
else
    str = '';
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% SUBFUNCTION that merges the fields of two structs into one
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

function smerged=mergestruct(struct1, struct2)

if isempty(struct1)
    smerged=struct2;
    return;
end
if isempty(struct2)
    smerged=struct1;
    return;
end

names1 = fieldnames(struct1);
names2 = fieldnames(struct2);

if ~isempty(intersect(names1, names2))
    error('Structures with common fields cannot be merged');
end

data1=struct2cell(struct1);
data2=struct2cell(struct2);

smerged=cell2struct([data1; data2], [names1; names2], 1);
