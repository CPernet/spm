function conf = spm_config_fmri_stats
% Configuration file for fmri statistics jobs

% DRG CS-RCS: $Id: spm_config_fmri_stats.m,v 1.1 2005-02-08 20:26:51-06 drg Exp drg $

% Define inline types.
%-----------------------------------------------------------------------
entry = inline(['struct(''type'',''entry'',''name'',name,'...
    '''tag'',tag,''strtype'',strtype,''num'',num,''help'',hlp)'],...
    'name','tag','strtype','num','hlp');

files = inline(['struct(''type'',''files'',''name'',name,'...
    '''tag'',tag,''filter'',fltr,''num'',num,''help'',hlp)'],...
    'name','tag','fltr','num','hlp');

mnu = inline(['struct(''type'',''menu'',''name'',name,'...
    '''tag'',tag,''labels'',{labels},''values'',{values},''help'',hlp)'],...
    'name','tag','labels','values','hlp');

branch = inline(['struct(''type'',''branch'',''name'',name,'...
    '''tag'',tag,''val'',{val},''help'',hlp)'],...
    'name','tag','val','hlp');

repeat = inline(['struct(''type'',''repeat'',''name'',name,'...
    '''tag'',tag,''values'',{values},''help'',hlp)'],...
    'name','tag','values','hlp');

choice = inline(['struct(''type'',''choice'',''name'',name,'...
    '''tag'',tag,''values'',{values},''help'',hlp)'],...
    'name','tag','values','hlp');

%-----------------------------------------------------------------------

w = spm_jobman('HelpWidth');

%_______________________________________________________________________

onset   = entry('Onsets','onset','e',[Inf 1],'Vector of onsets');
p1 = spm_justify(w,...
  'Specify a vector of onset times for this trial/condition type.');
p2 = spm_justify(w,...
  'With longs TRs you may want to shift the regressors so that they are',...
  'aligned to a particular slice.  This is effected by resetting the',...
  'values of defaults.stats.fmri.t and defaults.stats.fmri.t0 in',...
  'spm_defaults. defaults.stats.fmri.t is the number of time-bins per',...
  'scan used when building regressors.  Onsets are defined',...
  'in temporal units of scans starting at 0.  defaults.stats.fmri.t0 is',...
  'the first time-bin at which the regressors are resampled to coincide',...
  'with data acquisition.  If defaults.stats.fmri.t0 = 1 then the',...
  'regressors will be appropriate for the first slice.  If you want to',...
  'temporally realign the regressors so that they match responses in the',...
  'middle slice then make defaults.stats.fmri.t0 =',...
  'defaults.stats.fmri.t/2 (assuming there is a negligible gap between',...
  'volume acquisitions. Default values are defaults.stats.fmri.t = 16',...
  'and defaults.stats.fmri.t0 = 1.');
onset.help = {p1{:},'','Slice Timing Information',p2{:}};
%-------------------------------------------------------------------------
duration = entry('Durations','duration','e',[Inf 1],'Duration/s');
duration.help = spm_justify(w,...
  'Specify the event durations (in seconds). Epoch and event-related',...
  'responses are modeled in exactly the same way but by specifying their',...
  'different durations.  Events are',...
  'specified with a duration of 0.  If you enter a single number for the',...
  'durations it will be assumed that all trials conform to this duration.',...
  'If you have multiple different durations, then the number must match the',...
  'number of onset times.');
%-------------------------------------------------------------------------
time_mod = mnu('Time Modulation','tmod',...
    {'No Time Modulation','1st order Time Modulation',...
     '2nd order Time Modulation','3rd order Time Modulation',...
     '4th order Time Modulation','5th order Time Modulation',...
     '6th order Time Modulation'},...
    {0,1,2,3,4,5,6},'');
time_mod.val = {0};
p1 = spm_justify(w,...
  'Model interractions with time?  This allows nonlinear effects over time',...
  'to be modelled in the design matrix.  For example, 1st order modulation',...
  'would model the stick functions and a linear change of the stick function',...
  'heights over time. Higher order modulation will introduce further columns that',...
  'contain the stick functions scaled by time squared, time cubed etc.');
p2 = spm_justify(w,...
  'Interactions or response modulations can enter at two levels.  Firstly',...
  'the stick function itself can be modulated by some parametric variate',...
  '(this can be time or some trial-specific variate like reaction time)',...
  'modeling the interaction between the trial and the variate or, secondly',...
  'interactions among the trials themselves can be modeled using a Volterra',...
  'series formulation that accommodates interactions over time (and therefore',...
  'within and between trial types).');
time_mod.help = {p1{:},'',p2{:}};
%-------------------------------------------------------------------------
%ply = mnu('Polynomial Expansion','poly',...
%    {'None','1st order','2nd order','3rd order','4th order','5th order','6th order'},...
%    {0,1,2,3,4,5,6},'Polynomial Order');
%ply.val = {0};
%-------------------------------------------------------------------------
name      = entry('Name','name','s', [1 Inf],'Name of parameter');
name.val  = {'Param'};
name.help = spm_justify(w,'Enter a name for this parameter.');
%-------------------------------------------------------------------------
param  = entry('Values','param','e',[Inf 1],'Parameter vector');
param.help = spm_justify(w,'Enter a vector of values, one for each occurence of the event.');
%-------------------------------------------------------------------------
ply = mnu('Polynomial Expansion','poly',...
    {'1st order','2nd order','3rd order','4th order','5th order','6th order'},...
    {1,2,3,4,5,6},'Polynomial Order');
ply.val = {1};
ply.help = spm_justify(w,...
  'For example, 1st order modulation',...
  'would model the stick functions and a linear change of the stick function',...
  'heights over different values of the parameter. Higher order modulation will',...
  'introduce further columns that',...
  'contain the stick functions scaled by parameter squared, cubed etc.');
%-------------------------------------------------------------------------
pother = branch('Parameter','mod',{name,param,ply},'Custom parameter');
p1 = spm_justify(w,...
  'Model interractions with user specified parameters.',...
  'This allows nonlinear effects relating to some other measure',...
  'to be modelled in the design matrix.');
p2 = spm_justify(w,...
  'Interactions or response modulations can enter at two levels.  Firstly',...
  'the stick function itself can be modulated by some parametric variate',...
  '(this can be time or some trial-specific variate like reaction time)',...
  'modeling the interaction between the trial and the variate or, secondly',...
  'interactions among the trials themselves can be modeled using a Volterra',...
  'series formulation that accommodates interactions over time (and therefore',...
  'within and between trial types).');
pother.help = {p1{:},'',p2{:}};
%-------------------------------------------------------------------------
mod      = repeat('Parametric Modulations','mod',{pother},'');
mod.help = spm_justify(w,...
  'The stick function itself can be modulated by some parametric variate',...
  '(this can be time or some trial-specific variate like reaction time)',...
  'modeling the interaction between the trial and the variate.',...
  'The events can be modulated by zero or more parameters.');
%-------------------------------------------------------------------------
name     = entry('Name','name','s',[1 Inf],'Condition Name');
name.val = {'Trial'};
%-------------------------------------------------------------------------
cond  = branch('Condition/Trial','cond',{name,onset,duration,time_mod,mod},...
    'Condition/Trial');
cond.check = @cond_check;
cond.help = spm_justify(w,...
  'An array of input functions is contructed,',...
  'specifying occurrence events or epochs (or both).',...
  'These are convolved with a basis set at a later stage to give',...
  'regressors that enter into the design matrix. Interactions of evoked',...
  'responses with some parameter (time or a specified variate) enter at',...
  'this stage as additional columns in the design matrix with each trial multiplied',...
  'by the [expansion of the] trial-specific parameter.',...
  'The 0th order expansion is simply the main effect in the first column.');
%-------------------------------------------------------------------------
conditions = repeat('Conditions/Trials','condrpt',{cond},'Conditions');
conditions.help = spm_justify(w,...
  'You are allowed to combine both event- and epoch-related',...
  'responses in the same model and/or regressor. Any number',...
  'of trial (event or epoch) types can be specified.  Epoch and event-related',...
  'responses are modeled in exactly the same way by specifying their',...
  'onsets [in terms of onset times] and their durations.  Events are',...
  'specified with a duration of 0.  If you enter a single number for the',...
  'durations it will be assumed that all trials conform to this duration.');
%-------------------------------------------------------------------------
name     = entry('Name','name','s',[1 Inf],'Regressor Name');
name.val = {'Regressor'};
%-------------------------------------------------------------------------
val      = entry('Value','val','e',[Inf 1],'Param Value');
%-------------------------------------------------------------------------
regress  = branch('Regressor','regress',{name,val},'regressor');
regressors = repeat('Regressors','regress',{regress},'Regressors');
regressors.help = spm_justify(w,...
  'Regressors are additional columns included in the design matrix,',...
  'which may model effects that would not be convolved with the',...
  'haemodynamic response.  One such example would be the estimated movement',...
  'parameters, which may confound the data.');
%-------------------------------------------------------------------------
scans    = files('Scans','scans','image',[1 Inf],'Select scans');
scans.help = spm_justify(w,...
'Select the scans for this session.  Note that they all need to have the same',...
'image dimensions, orientation, voxel size etc.');
%-------------------------------------------------------------------------
hpf      = entry('High-pass filter','hpf','e',[1 1],'');
hpf.val  = {Inf};
hpf.help = spm_justify(w,...
    'High-pass filtering is implemented at the level of the',...
    'filtering matrix K (as opposed to entering as confounds in the design',...
    'matrix).  The default cutoff period is 128 seconds.  Use ''explore design''',...
    'to ensure this cuttof is not removing too much experimental variance.',...
    'Note that high-pass filtering uses a residual forming matrix (i.e.',...
    'it is not a convolution) and is simply to a way to remove confounds',...
    'without estimating their parameters explicitly.  The constant term',...
    'is also incorportated into this filter matrix.');
%-------------------------------------------------------------------------
sess  = branch('Subject/Session','sess',{scans,conditions,regressors,hpf},'Session');
sess.check = @sess_check;
p1 = spm_justify(w,...
'The design matrix for fMRI data consists of one or more seperable,',...
'session-specific partitions.  These partitions are usually either one per',...
'subject, or one per fMRI scanning session for that subject.');
sess.help = p1;
%-------------------------------------------------------------------------
block = repeat('Data & Design','blocks',{sess},'');
p1 = spm_justify(w,...
  'The design matrix defines the experimental design and the nature of',...
  'hypothesis testing to be implemented.  The design matrix has one row',...
  'for each scan and one column for each effect or explanatory variable.',...
  '(e.g. regressor or stimulus function).  The parameters are estimated in',...
  'a least squares sense using the general linear model.  Specific profiles',...
  'within these parameters are tested using a linear compound or contrast',...
  'with the T or F statistic.  The resulting statistical map constitutes',...
  'an SPM.  The SPM{T}/{F} is then characterized in terms of focal or regional',...
  'differences by assuming that (under the null hypothesis) the components of',...
  'the SPM (i.e. residual fields) behave as smooth stationary Gaussian fields.');
p2 = spm_justify(w,...
  'This allows you to build design matrices with separable',...
  'session-specific partitions.  Each partition may be the same (in which',...
  'case it is only necessary to specify it once) or different.  Responses',...
  'can be either event- or epoch related, where the latter model prolonged',...
  'and possibly time-varying responses to state-related changes in',...
  'experimental conditions.  Event-related response are modelled in terms',...
  'of responses to instantaneous events.  Mathematically they are both',...
  'modelled by convolving a series of delta (stick) or box-car functions,',...
  'encoding the input or stimulus function. with a set of hemodynamic',...
  'basis functions.');
block.help = {'Specify the Data and Design','',p1{:},'',p2{:}};
%-------------------------------------------------------------------------
rt       = entry('Interscan interval','RT','e',[1 1],'Interscan interval {secs}');
rt.help = spm_justify(w,...
'Interscan interval {secs}.  This is the time between acquiring a plane of one volume',...
'and the same plane in the next volume.  It is assumed to be constant throughout.');
%-------------------------------------------------------------------------
units    = mnu('Units for design spec','units',{'Scans','Seconds'},{'scans','secs'},'');
units.help = spm_justify(w,...
'Units for design spec.');
%-------------------------------------------------------------------------
glob  = mnu('Global normalisation','global',...
    {'Scaling','None'},{'Scaling','None'},'Global intensity normalisation');
%-------------------------------------------------------------------------
cvi   = mnu('Serial correlations','cvi',{'none','AR(1)'},{'none','AR(1)'},...
    'Correct for serial correlations');
p1 = spm_justify(w,...
    'Serial correlations in fast fMRI time-series are dealt with as',...
    'described in spm_spm.  At this stage you need to specify the filtering',...
    'that will be applied to the data (and design matrix) to give a',...
    'generalized least squares (GLS) estimate of the parameters required.',...
    'This filtering is important to ensure that the GLS estimate is',...
    'efficient and that the error variance is estimated in an unbiased way.');
p2 = spm_justify(w,...
    'The serial correlations will be estimated with a ReML (restricted',...
    'maximum likelihood) algorithm using an autoregressive AR(1) model',...
    'during parameter estimation.  This estimate assumes the same',...
    'correlation structure for each voxel, within each session.  The ReML',...
    'estimates are then used to correct for non-sphericity during inference',...
    'by adjusting the statistics and degrees of freedom appropriately.  The',...
    'discrepancy between estimated and actual intrinsic (i.e. prior to',...
    'filtering) correlations are greatest at low frequencies.  Therefore',...
    'specification of the high-pass filter is particularly important.');
cvi.help = {p1{:},p2{:}};

%-----------------------------------------------------------------------

% These are currently unused
%hrfpar = entry('Parameters','params','e',[1 7],'HRF Parameters');
%hrfpar.val = {[6 16 1 1 6 0 32]};
%hrfpar.help = {...
%    'The parameters are:',...
%    '   p(1) - delay of response (relative to onset)       6',...
%    '   p(2) - delay of undershoot (relative to onset)    16',...
%    '   p(3) - dispersion of response                      1',...
%    '   p(4) - dispersion of undershoot                    1',...
%    '   p(5) - ratio of response to undershoot             6',...
%    '   p(6) - onset (seconds)                             0',...
%    '   p(7) - length of kernel (seconds)                 32'};

%-------------------------------------------------------------------------
derivs = mnu('Model derivatives','derivs',...
    {'No derivatives', 'Time derivatives', 'Time and Dispersion derivatives'},...
    {[0 0],[1 0],[1 1]},'Model HRF Derivatives');
derivs.val = {[0 0]};
derivs.help = spm_justify(w,...
'Model HRF Derivatives.  Modelling time and dispersion derivatives is recommended',...
'if you plan to use a second level analyses of event related fMRI.'); 
%-------------------------------------------------------------------------
hrf   = branch('Canonical HRF','hrf',{derivs},'Canonical Heamodynamic Response Function');
hrf.help = spm_justify(w,...
'Canonical Heamodynamic Response Function - Useful if (i) you wish to use a SPM{T} to',...
'look separately at activations and deactivations or (ii) you wish to proceed to a second',...
'(random-effect) level of analysis.',...
'Unlike other bases, contrasts of these effects have a physical interpretation',...
'and represent a parsimonious way of characterising event-related',...
'responses.');
%-------------------------------------------------------------------------
len   = entry('Window length','length','e',[1 1],'window length {secs}');
order = entry('Order','order','e',[1 1],'order');
o1    = branch('Fourier Set','fourier',{len,order},'');
o1.help = spm_justify(w,'Fourier basis functions - requires SPM{F} for inference.');
o2    = branch('Fourier Set (Hanning)','fourier_han',{len,order},'');
o2.help = spm_justify(w,'Fourier basis functions with Hanning Window - requires SPM{F} for inference.');
o3    = branch('Gamma Functions','gamma',{len,order},'');
o3.help = spm_justify(w,'Gamma basis functions - requires SPM{F} for inference.');
o4    = branch('Finite Impulse Response','fir',{len,order},'');
o4.help = spm_justify(w,'Finite impulse response - requires SPM{F} for inference.');
%-------------------------------------------------------------------------
bases = choice('Basis Functions','bases',{hrf,o1,o2,o3,o4},'');
bases.val = {hrf};
bases.help = spm_justify(w,...
    'The choice of basis functions depends upon the nature of the inference',...
    'sought.  One important consideration is whether you want to make',...
    'inferences about compounds of parameters (i.e.  contrasts).  This is',...
    'the case if (i) you wish to use a SPM{T} to look separately at',...
    'activations and deactivations or (ii) you wish to proceed to a second',...
    '(random-effect) level of analysis.  If this is the case then (for',...
    'event-related studies) use a canonical hemodynamic response function',...
    '(HRF) and derivatives with respect to latency (and dispersion).  Unlike',...
    'other bases, contrasts of these effects have a physical interpretation',...
    'and represent a parsimonious way of characterising event-related',...
    'responses.  Bases such as a Fourier set require the SPM{F} for',...
    'inference.');
%-------------------------------------------------------------------------
volt  = mnu('Model Interactions (Volterra)','volt',{'Do not model Interractions','Model Interractions'},{1,2},'');
volt.val = {1};
p1 = spm_justify(w,'Generalized convolution of inputs (U) with basis set (bf).');
p2 = spm_justify(w,...
  'For first order expansions the causes are simply convolved',...
  '(e.g. stick functions) in U.u by the basis functions in bf to create',...
  'a design matrix X.  For second order expansions new entries appear',...
  'in ind, bf and name that correspond to the interaction among the',...
  'orginal causes. The basis functions for these efects are two dimensional',...
  'and are used to assemble the second order kernel in spm_graph.m.',...
  'Second order effects are computed for only the first column of U.u.');
p3 = spm_justify(w,...
  'Interactions or response modulations can enter at two levels.  Firstly',...
  'the stick function itself can be modulated by some parametric variate',...
  '(this can be time or some trial-specific variate like reaction time)',...
  'modeling the interaction between the trial and the variate or, secondly',...
  'interactions among the trials themselves can be modeled using a Volterra',...
  'series formulation that accommodates interactions over time (and therefore',...
  'within and between trial types).');
volt.help = {p1{:},'',p2{:},p3{:}};
%-------------------------------------------------------------------------
mask = files('Explicit mask','mask','image',[0 1],'Image for explicitly masking the analysis');
mask.val = {''};
%-------------------------------------------------------------------------
cdir = files('Directory','dir','dir',1,'');
cdir.help = spm_justify(w,...
'Select an analysis directory to change to.',...
'This is where the results of the statistics will be written.');
%-------------------------------------------------------------------------
conf = branch('FMRI Stats','fmri_stats',...
    {block,bases,volt,cdir,rt,units,glob,cvi,mask},'fMRI design');
conf.prog   = @run_stats;
conf.vfiles = @vfiles_stats;
conf.check  = @check_dir;
conf.modality = {'FMRI'};
p1 = spm_justify(w,...
  'This configures the design matrix, data specification and',...
  'filtering that specify the ensuing statistical analysis. These',...
  'arguments are passed to spm_spm that then performs the actual parameter',...
  'estimation.');
p2 = spm_justify(w,...
  'The design matrix defines the experimental design and the nature of',...
  'hypothesis testing to be implemented.  The design matrix has one row',...
  'for each scan and one column for each effect or explanatory variable.',...
  '(e.g. regressor or stimulus function).  The parameters are estimated in',...
  'a least squares sense using the general linear model.  Specific profiles',...
  'within these parameters are tested using a linear compound or contrast',...
  'with the T or F statistic.  The resulting statistical map constitutes',...
  'an SPM.  The SPM{T}/{F} is then characterized in terms of focal or regional',...
  'differences by assuming that (under the null hypothesis) the components of',...
  'the SPM (i.e. residual fields) behave as smooth stationary Gaussian fields.');
p3 = spm_justify(w,...
  'You (i) specify a statistical model in terms',...
  'of a design matrix, (ii) associate some data with a pre-specified design',...
  '[or (iii) specify both the data and design] and then proceed to estimate',...
  'the parameters of the model.',...
  'Inferences can be made about the ensuing parameter estimates (at a first',...
  'or fixed-effect level) in the results section, or they can be re-entered',...
  'into a second (random-effect) level analysis by treating the session or',...
  'subject-specific [contrasts of] parameter estimates as new summary data.',...
  'Inferences at any level obtain by specifying appropriate T or F contrasts',...
  'in the results section to produce SPMs and tables of p values and statistics.');
p4 = spm_justify(w,...
  'You can build design matrices with separable',...
  'session-specific partitions.  Each partition may be the same (in which',...
  'case it is only necessary to specify it once) or different.  Responses',...
  'can be either event- or epoch related, The only distinction is the duration',...
  'of the underlying input or stimulus function. Mathematically they are both',...
  'modeled by convolving a series of delta (stick) or box functions (u),',...
  'indicating the onset of an event or epoch with a set of basis',...
  'functions.  These basis functions model the hemodynamic convolution,',...
  'applied by the brain, to the inputs.  This convolution can be first-order',...
  'or a generalized convolution modeled to second order (if you specify the',...
  'Volterra option). [The same inputs are used by the hemodynamic model or',...
  'or dynamic causal models which model the convolution explicitly in terms of',...
  'hidden state variables (see spm_hdm_ui and spm_dcm_ui).]',...
  'Basis functions can be used to plot estimated responses to single events',...
  'once the parameters (i.e. basis function coefficients) have',...
  'been estimated.  The importance of basis functions is that they provide',...
  'a graceful transition between simple fixed response models (like the',...
  'box-car) and finite impulse response (FIR) models, where there is one',...
  'basis function for each scan following an event or epoch onset.  The',...
  'nice thing about basis functions, compared to FIR models, is that data',...
  'sampling and stimulus presentation does not have to be synchronized',...
  'thereby allowing a uniform and unbiased sampling of peri-stimulus time.');
p5 = spm_justify(w,...
  'Event-related designs may be stochastic or deterministic.  Stochastic',...
  'designs involve one of a number of trial-types occurring with a',...
  'specified probably at successive intervals in time.  These',...
  'probabilities can be fixed (stationary designs) or time-dependent',...
  '(modulated or non-stationary designs).  The most efficient designs',...
  'obtain when the probabilities of every trial type are equal.',...
  'A critical issue in stochastic designs is whether to include null events',...
  'If you wish to estimate the evoke response to a specific event',...
  'type (as opposed to differential responses) then a null event must be',...
  'included (even if it is not modeled explicitly).');
r1 = spm_justify(w,...
  'Friston KJ, Holmes A, Poline J-B, Grasby PJ, Williams SCR, Frackowiak',...
  'RSJ & Turner R (1995) Analysis of fMRI time-series revisited. NeuroImage',...
  '2:45-53');
r2 = spm_justify(w,...
  'Worsley KJ and Friston KJ (1995) Analysis of fMRI time-series revisited -',...
  'again. NeuroImage 2:178-181');
r3 = spm_justify(w,...
  'Friston KJ, Frith CD, Frackowiak RSJ, & Turner R (1995) Characterising',...
  'dynamic brain responses with fMRI: A multivariate approach NeuroImage -',...
  '2:166-172');
r4 = spm_justify(w,...
  'Frith CD, Turner R & Frackowiak RSJ (1995) Characterising evoked',...
  'hemodynamics with fMRI Friston KJ, NeuroImage 2:157-165');
r5 = spm_justify(w,...
  'Josephs O, Turner R and Friston KJ (1997) Event-related fMRI, Hum. Brain',...
  'Map. 0:00-00');
conf.help = {'fMRI Statistics','',p1{:},'',p2{:},'',p3{:},'',p4{:},'',p5{:},...
             '','Refs:',r1{:},'',r2{:},'',r3{:},'',r4{:},'',r5{:}};

return;
%-------------------------------------------------------------------------

%-------------------------------------------------------------------------
function t = check_dir(job)
t = {};
%d = pwd;
%try,
%    cd(job.dir{1});
%catch,
%    t = {['Cannot Change to directory "' job.dir{1} '".']};
%end;

%disp('Checking...');
%disp(fullfile(job.dir{1},'SPM.mat'));

% Should really include a check for a "virtual" SPM.mat
if exist(fullfile(job.dir{1},'SPM.mat'),'file'),
    t = {'SPM files exist in the analysis directory.'};
end;
return;
%-------------------------------------------------------------------------

%-------------------------------------------------------------------------
function t = cond_check(job)
t   = {};
if (numel(job.onset) ~= numel(job.duration)) && (numel(job.duration)~=1),
    t = {sprintf('"%s": Number of event onsets (%d) does not match the number of durations (%d).',...
        job.name, numel(job.onset),numel(job.duration))};
end;
for i=1:numel(job.mod),
    if numel(job.onset) ~= numel(job.mod(i).param),
        t = {t{:}, sprintf('"%s" & "%s":Number of event onsets (%d) does not equal the number of parameters (%d).',...
            job.name, job.mod(i).name, numel(job.onset),numel(job.mod(i).param))};
    end;
end;
return;
%-------------------------------------------------------------------------

%-------------------------------------------------------------------------
function t = sess_check(sess)
t = {};
for i=1:numel(sess.regress),
    if numel(sess.scans) ~= numel(sess.regress(i).val),
        t = {t{:}, sprintf('Num scans (%d) ~= Num regress[%d] (%d).',numel(sess.scans),i,numel(sess.regress(i).val))};
    end;
end;
return;
%-------------------------------------------------------------------------

%-------------------------------------------------------------------------
function my_cd(varargin)
job = varargin{1};
if ~isempty(job)
    try
    cd(char(job));
    fprintf('Changing directory to: %s\n',char(job));
    catch
        error('Failed to change directory. Aborting run.')
    end
end
return;
%------------------------------------------------------------------------

%------------------------------------------------------------------------
function run_stats(job)
% Set up the design matrix and run a design.

global defaults

original_dir = pwd;
my_cd(job.dir);

% If we've gotten to this point we're committed to overwriting files.
% Delete them so we don't get stuck in spm_spm
%------------------------------------------------------------------------
files = {'mask.???','ResMS.???','RVP.???',...
    'beta_????.???','con_????.???','ResI_????.???',...
    'ess_????.???', 'spm?_????.???'};
for i=1:numel(files),
    if any(files{i} == '*' | files{i} == '?')
        [j,unused] = spm_list_files(pwd,files{i});
        for i=1:size(j,1),
            spm_unlink(deblank(j(i,:)));
        end
    else
        spm_unlink(files{i});
    end
end


% Variables
%-------------------------------------------------------------
SPM.xY.RT = job.RT;
SPM.xY.P = [];

% Basis function variables
%-------------------------------------------------------------
SPM.xBF.UNITS = job.units;
SPM.xBF.dt    = job.RT/defaults.stats.fmri.t;
SPM.xBF.T     = defaults.stats.fmri.t;
SPM.xBF.T0    = defaults.stats.fmri.t0;

% Basis functions
%-------------------------------------------------------------
if strcmp(fieldnames(job.bases),'hrf')
    if all(job.bases.hrf.derivs == [0 0])
        SPM.xBF.name = 'hrf';
    elseif all(job.bases.hrf.derivs == [1 0])
        SPM.xBF.name = 'hrf (with time derivative)';
    elseif all(job.bases.hrf.derivs == [1 1])
        SPM.xBF.name = 'hrf (with time and dispersion derivatives)';
    else
        error('Unrecognized hrf derivative choices.')
    end
else
    nam = fieldnames(job.bases);
    switch nam,
        case 'fourier',
            SPM.xBF.name = 'Fourier set';
        case 'fourier_han', 
            SPM.xBF.name = 'Fourier set (Hanning)';
        case 'gamma',
            SPM.xBF.name = 'Gamma functions';
        case 'fir',
            SPM.xBF.name = 'Finite Impulse Response';
        otherwise
            error('Unrecognized hrf derivative choices.')
    end
    SPM.xBF.length = job.bases.(nam).length;
    SPM.xBF.order  = job.bases.(nam).order;
end
SPM.xBF          = spm_get_bf(SPM.xBF);
if isempty(job.sess),
    SPM.xBF.Volterra = false;
else
    SPM.xBF.Volterra = job.volt;
end;

for i = 1:numel(job.sess),
    sess = job.sess(i);

    % Image filenames
    %-------------------------------------------------------------
    SPM.nscan(i) = size(sess.scans,1);
    SPM.xY.P     = strvcat(SPM.xY.P,sess.scans{:});

    U = [];

    % Configure the input structure array
    %-------------------------------------------------------------
    for j = 1:length(sess.cond),
        cond      = sess.cond(j);
        U(j).name = {cond.name};
        U(j).ons  = cond.onset(:);
        U(j).dur  = cond.duration(:);
        if length(U(j).dur) == 1
            U(j).dur    = U(j).dur*ones(size(U(j).ons));
        elseif length(U(j).dur) ~= length(U(j).ons)
            error('Mismatch between number of onset and number of durations.')
        end

        P  = [];
        q1 = 0;
        if cond.tmod>0,
            % time effects
            P(1).name = 'time';
            P(1).P    = U(j).ons*RT;
            P(1).h    = cond.tmod;
            q1        = 1;
        end;
        for q = 1:numel(cond.mod),
            % Parametric effects
            q1 = q1 + 1;
            P(q1).name = cond.mod(q).name;
            P(q1).P    = cond.mod(q).param;
            P(q1).h    = cond.mod(q).poly;
        end;
        if isempty(P)
            P.name = 'none';
            P.h    = 0;
        end
        U(j).P = P;

    end

    SPM.Sess(i).U = U;


    % User specified regressors
    %-------------------------------------------------------------
    C = [];
    Cname = cell(1,numel(sess.regress));
    for q = 1:numel(sess.regress),
        Cname{q} = sess.regress(q).name;
        C         = [C, sess.regress(q).val(:)];
    end
    SPM.Sess(i).C.C    = C;
    SPM.Sess(i).C.name = Cname;

end

% Globals
%-------------------------------------------------------------
SPM.xGX.iGXcalc = job.global;
SPM.xGX.sGXcalc = 'mean voxel value';
SPM.xGX.sGMsca  = 'session specific';

% High Pass filter
%-------------------------------------------------------------
SPM.xX.K(1).HParam = job.sess(i).hpf;

% Autocorrelation
%-------------------------------------------------------------
SPM.xVi.form = job.cvi;

% Let SPM configure the design
%-------------------------------------------------------------
SPM = spm_fmri_spm_ui(SPM);

if ~isempty(job.mask)
    SPM.xM.VM         = spm_vol(job.mask{:});
    SPM.xM.xs.Masking = [SPM.xM.xs.Masking, '+explicit mask'];
end

%-Save SPM.mat
%-----------------------------------------------------------------------
fprintf('%-40s: ','Saving SPM configuration with explicit mask')   %-#
if str2num(version('-release'))>=14,
    save('SPM','-V6','SPM');
else
    save('SPM','SPM');
end;

fprintf('%30s\n','...SPM.mat with mask saved')                     %-#

SPM = spm_spm(SPM);

my_cd(original_dir); % Change back

fprintf('Done\n')
return
%-------------------------------------------------------------------------

%-------------------------------------------------------------------------
function vf = vfiles_stats(job)
direc = job.dir{1};
vf    = {fullfile(direc,'SPM.mat')};

% Should really create a few vfiles for beta images etc here as well.

