function conf = spm_config_fmri_stats
% Configuration file for fmri statistics jobs

% DRG CS-RCS: $Id: spm_config_fmri_stats.m,v 1.1 2005-02-08 20:26:51-06 drg Exp drg $

% Define inline types.
%-----------------------------------------------------------------------
const = inline(['struct(''type'',''const'',''name'',name,'...
    '''tag'',tag,''val'',{val},''help'',hlp)'],...
    'name','tag','val','hlp');

entry = inline(['struct(''type'',''entry'',''name'',name,'...
    '''tag'',tag,''strtype'',strtype,''num'',num,''help'',hlp)'],...
    'name','tag','strtype','num','hlp');

files = inline(['struct(''type'',''files'',''name'',name,'...
    '''tag'',tag,''filter'',fltr,''num'',num,''help'',hlp)'],...
    'name','tag','fltr','num','hlp');

mnu = inline(['struct(''type'',''menu'',''name'',name,'...
    '''tag'',tag,''labels'',{labels},''values'',{values},''help'',hlp)'],...
    'name','tag','labels','values','hlp');

branch = inline(['struct(''type'',''branch'',''name'',name,'...
    '''tag'',tag,''val'',{val},''help'',hlp)'],...
    'name','tag','val','hlp');

repeat = inline(['struct(''type'',''repeat'',''name'',name,'...
    '''tag'',tag,''values'',{values},''help'',hlp)'],...
    'name','tag','values','hlp');

choice = inline(['struct(''type'',''choice'',''name'',name,'...
    '''tag'',tag,''values'',{values},''help'',hlp)'],...
    'name','tag','values','hlp');


%-----------------------------------------------------------------------

w = spm_jobman('HelpWidth');

%_______________________________________________________________________

% tmod = mnu('Temporal Modulation','tmod',...
% 	{'None','1st order','2nd order','3rd order','4th order','5th order','6th order'},...
% 	{0,1,2,3,4,5,6},'');
% tmod.val = {0};
% tmod.help = spm_justify(w,...
% '');

ply = mnu('Polynomial Expansion','poly',...
    {'None','1st order','2nd order','3rd order','4th order','5th order','6th order'},...
    {0,1,2,3,4,5,6},'Polynomial Order');
ply.val = {0};

% % name     = mnu('Name','name','s',[1 Inf],'Parameter Name');
name     = entry('Parameter name','name','s',...
    [1 1],'Name of parameter');
name.val = {'My parameter'};

param = entry('param','param','e',[-1 1],'Parameter vector');
%
pnone   = const('None','none',{'none'},'none');

ptime = branch('Time','ptime',{ply},'Polynomial order');

pother = branch('Other','pother',{name,param,ply},'Custom parameter');

ptype     = choice('Modulation type','ptype',...
    {pnone,ptime,pother},'Parametric modulation type');

mod      = repeat('Parametric Modulation','mod',{ptype},'');

% mod      = repeat('Parametric Modulation','mod',{...
% 	branch('Modulation function','mod',{...
% 		name,...
% 		entry('Param Value','val','e',[-1 1],'Param Value'),...
% 		ply...
% 	},'')...
% },'');
%
% name.val = {'Trial'};
% onsets   = entry('Onset Vector','onset','e',[-1 1],'Vector of onsets');
% duration = entry('Duration','duration','e',[1 1],'Duration');
% fixdur   = branch('Constant Duration Trial','fixdur',{name,onsets,duration,mod},...
% 	'Fixed Duration Condition');
% fixdur.dim = Inf;

name     = entry('Name','name','s',[1 Inf],'Condition Name');
name.val = {'Trial'};
onsets   = entry('Onsets','onset','e',[-1 1],'Vector of onsets');

duration = entry('Duration','duration','e',[1 1],'Duration');
cond  = branch('Fixed Duration Trial','fixcond',{name,onsets,duration,mod},...
    'Fixed Duration Condition');
cond.dim = Inf;

duration = entry('Durations','duration','e',[-1 1],'Vector of durations');
cond1  = branch('Variable Duration Trial','varcond',{name,onsets,duration,mod},...
    'Variable Duration Condition');
cond1.dim =  Inf;

conditions = repeat('Conditions/Trials','condrpt',{cond,cond1},'Conditions');
% conditions.dim = Inf;

name     = entry('Name','name','s',[1 Inf],'Regressor Name');
name.val = {'Other Regressor'};
val      = entry('Value','val','e',[-1 1],'Param Value');
regress  = branch('Regressor','regress',{name,val},'regressor');
regressors = repeat('Regressors','regress',{regress},'Regressors');

scans    = files('Scans','scans','image',[1 -1],'Select scans');
hpf      = entry('High-pass filter','hpf','e',[1 1],'');
hpf.val  = {Inf};
hpf.help = spm_justify(w,...
    'High-pass filtering is implemented at the level of the',...
    'filtering matrix K (as opposed to entering as confounds in the design',...
    'matrix).  The default cutoff period is 128 seconds.  Use ''explore design''',...
    'to ensure this cuttof is not removing too much experimental variance.',...
    'Note that high-pass filtering uses a residual forming matrix (i.e.',...
    'it is not a convolution) and is simply to a way to remove confounds',...
    'without estimating their parameters explicitly.  The constant term',...
    'is also incorportated into this filter matrix.');


volt  = mnu('Model Interactions?','volt',{'Do not model Interractions','Model Interractions'},{1,2},'');
volt.val = {1};

sess  = branch('Subject/Session','sess',{scans,conditions,volt,regressors,hpf},'Session');
sess.dim = Inf;
block = repeat('Data & Design','blocks',{sess},'');
block.help = spm_justify(w,...
    'The design matrix defines the experimental design and the nature of',...
    'hypothesis testing to be implemented.  The design matrix has one row',...
    'for each scan and one column for each effect or explanatory variable.',...
    '(e.g. regressor or stimulus function).  The parameters are estimated in',...
    'a least squares sense using the general linear model.  Specific profiles',...
    'within these parameters are tested using a linear compound or contrast',...
    'with the T or F statistic.  The resulting statistical map constitutes',...
    'an SPM.  The SPM{T}/{F} is then characterized in terms of focal or regional',...
    'differences by assuming that (under the null hypothesis) the components of',...
    'the SPM (i.e. residual fields) behave as smooth stationary Gaussian fields.');


rt       = entry('Interscan interval','rt','e',[1 1],'Interscan interval {secs}');
units    = mnu('Units for design spec','units',{'Scans','Seconds'},{'scans','secs'},'');

glob  = mnu('Global normalisation','global',...
    {'Scaling','None'},{'Scaling','None'},'Global intensity normalisation');

cvi   = mnu('Serial correlations','cvi',{'none','AR(1)'},{'none','AR(1)'},...
    'Correct for serial correlations');
p1 = spm_justify(w,...
    'Serial correlations in fast fMRI time-series are dealt with as',...
    'described in spm_spm.  At this stage you need to specify the filtering',...
    'that will be applied to the data (and design matrix) to give a',...
    'generalized least squares (GLS) estimate of the parameters required.',...
    'This filtering is important to ensure that the GLS estimate is',...
    'efficient and that the error variance is estimated in an unbiased way.');
p2 = spm_justify(w,...
    'The serial correlations will be estimated with a ReML (restricted',...
    'maximum likelihood) algorithm using an autoregressive AR(1) model',...
    'during parameter estimation.  This estimate assumes the same',...
    'correlation structure for each voxel, within each session.  The ReML',...
    'estimates are then used to correct for non-sphericity during inference',...
    'by adjusting the statistics and degrees of freedom appropriately.  The',...
    'discrepancy between estimated and actual intrinsic (i.e. prior to',...
    'filtering) correlations are greatest at low frequencies.  Therefore',...
    'specification of the high-pass filter is particularly important.');
cvi.help = {p1{:},p2{:}};

%-----------------------------------------------------------------------

hrfpar = entry('Parameters','params','e',[1 7],'HRF Parameters');
hrfpar.val = {[6 16 1 1 6 0 32]};
derivs = mnu('Model derivatives','derivs',...
    {'No derivatives', 'Time derivatives', 'Time and Dispersion derivatives'},...
    {[0 0],[1 0],[1 1]},'Model HRF Derivatives');
derivs.val = {[0 0]};
hrf  = branch('Canonical HRF','hrf',{hrfpar,derivs},'Canonical Heamodynamic Response Function');
form = mnu('Forms','form',...
    {'Fourier set','Fourier set (Hanning)', 'Gamma functions','Finite Impulse Response'},...
    {1 2 3 4},'Form of responses');
form.val = {1};
len   = entry('Window length','length','e',[1 1],'window length {secs}');
order = entry('Order','order','e',[1 1],'order');
other = branch('Other Forms','other',{form,len,order},'Other forms');
bases = choice('Basis Functions','bases',{hrf,other},'');
bases.help = spm_justify(w,...
    'The choice of basis functions depends upon the nature of the inference',...
    'sought.  One important consideration is whether you want to make',...
    'inferences about compounds of parameters (i.e.  contrasts).  This is',...
    'the case if (i) you wish to use a SPM{T} to look separately at',...
    'activations and deactivations or (ii) you with to proceed to a second',...
    '(random-effect) level of analysis.  If this is the case then (for',...
    'event-related studies) use a canonical hemodynamic response function',...
    '(HRF) and derivatives with respect to latency (and dispersion).  Unlike',...
    'other bases, contrasts of these effects have a physical interpretation',...
    'and represent a parsimonious way of characterising event-related',...
    'responses.  Bases such as a Fourier set require the SPM{F} for',...
    'inference.');

mask = files('Explicit mask','mask','image',[0 1],'Image for explicitly masking the analysis');
mask.val = {''};

data.type = 'dirs';
data.name = 'Select analysis directory';
data.tag  = 'directory';
data.filter = '.';
data.num  = 1;
data.help = {'Select an analysis directory to change to.'};

cdir.type = 'branch';
cdir.name = 'Directory select';
cdir.tag  = 'cd';
cdir.val  = {data};
cdir.prog = @my_cd;
cdir.help = spm_justify(w,[...
'Change to the analysis directory.']);

owrite = mnu('Overwrite existing stats files?','owrite',{'Yes','No'},{1,0},'');
owrite.help = spm_justify(w,...
'Choose whether to overwrite pre-existing SPM analysis files.');


conf = branch('FMRI Stats','stats',...
    {cdir,owrite,block,bases,rt,units,glob,cvi,mask},'fMRI design');
conf.prog = @run_stats;
conf.vfiles = @vfiles_stats;
conf.modality = {'FMRI'};

return;
%-------------------------------------------------------------------------

%------------------------------------------------------------------------
function my_cd(varargin)
job = varargin{1};
if ~isempty(job)
    try
    cd(char(job));
    fprintf('Changing directory to: %s\n',char(job));
    catch
        error('Failed to change directory. Aborting run.')
    end
end
return;
%------------------------------------------------------------------------

%------------------------------------------------------------------------
function run_stats(varargin)
% Set up the design matrix and run a design.

global defaults
job = varargin{1};
my_cd(job.cd.directory)

if exist(fullfile('.','SPM.mat')) && ~job.owrite
    error('SPM files exist and analysis directory and no overwriting selected.')
end

% If we've gotten to this point we're committed to overwriting files.
% Delete them so we don't get stuck in spm_spm
%------------------------------------------------------------------------
files = {	'mask.???','ResMS.???','RVP.???',...
		'beta_????.???','con_????.???','ResI_????.???',...
		'ess_????.???', 'spm?_????.???'};
for i=1:length(files)
	if any(files{i} == '*'|files{i} == '?' )
		[j,null] = spm_list_files(pwd,files{i});
		for i=1:size(j,1)
			spm_unlink(deblank(j(i,:)))
		end
	else
		spm_unlink(files{i})
	end
end

% Variables
%-------------------------------------------------------------
global defaults

SPM.xY.RT = job.rt;
SPM.xY.P = [];
nsess = length(job.sess);

% Basis function variables
%-------------------------------------------------------------
SPM.xBF.UNITS = job.units;
SPM.xBF.dt    = job.rt/defaults.stats.fmri.t;
SPM.xBF.T     = defaults.stats.fmri.t;
SPM.xBF.T0    = defaults.stats.fmri.t0;

% Basis functions
%-------------------------------------------------------------
if strcmp(fieldnames(job.bases),'hrf')
    if all(job.bases.hrf.derivs == [0 0])
        SPM.xBF.name = 'hrf';
    elseif all(job.bases.hrf.derivs == [1 0])
        SPM.xBF.name = 'hrf (with time derivative)';
    elseif all(job.bases.hrf.derivs == [1 1])
        SPM.xBF.name = 'hrf (with time and dispersion derivatives)';
    else
        error('Unrecognized hrf derivative choices.')
    end
else
    switch job.bases.other.form
        case 1
            SPM.xBF.name = 'Fourier set';
        case 2
            SPM.xBF.name = 'Fourier set (Hanning)';
        case 3
            SPM.xBF.name = 'Gamma functions';
        case 4
            SPM.xBF.name = 'Finite Impulse Response';
        otherwise
            error('Unrecognized hrf derivative choices.')
    end
    SPM.xBF.length = job.bases.other.length;
    SPM.xBF.order  = job.bases.other.window;
end
SPM.xBF = spm_get_bf(SPM.xBF);
SPM.xBF.Volterra = job.sess.volt;

for i = 1:nsess
    % Image filenames
    %-------------------------------------------------------------
    SPM.nscan(i) = size(job.sess(i).scans,1);
    k     = SPM.nscan(i);
    SPM.xY.P = strvcat(SPM.xY.P,job.sess(i).scans{:});

    % Configure the input structure array
    %-------------------------------------------------------------
    for j= 1:length(job.sess(i).condrpt)
        if isfield(job.sess(i).condrpt{j},'fixcond')
            cond = job.sess(i).condrpt{j}.fixcond;
        else
            cond = job.sess(i).condrpt{j}.varcond;
        end        
        Uname = cond.name;
        U(j).name = {Uname};
        ons  = cond.onset(:);
        U(j).ons = ons;
        dur  = cond.duration(:);
        U(j).dur = dur;
        if length(dur) == 1
            dur    = dur*ones(size(ons));
        elseif length(dur) ~= length(ons)
            error('Mismatch between number of onsets and number of durations.')
        end

        % Parametric effects
        %-------------------------------------------------------------
        for q = 1:length(cond.ptype)
            ptype = char(fieldnames(cond.ptype{q}));

            switch ptype
                case {'pnone'}
                    P(q).name = 'none';
                    P(q).h    = 0;

                case {'ptime'}
                    P(q).name = 'time';
                    P.P = ons*TR;
                    P.h = cond.ptype{q}.ptime.poly;

                case {'pother'}
                    P(q).name = cond.ptype{q}.pother.name;
                    P(q).P = cond.ptype{q}.pother.param;
                    P(q).h = cond.ptype{q}.pother.poly;
            end
        end
        if isempty(cond.ptype)
            P.name = 'none';
            P.h    = 0;
        end
        U(j).P = P;

    end

    % Input structure array
    %-------------------------------------------------------------
    SPM.Sess(i).U = U;


    % User specified regressors
    %-------------------------------------------------------------
    C = [];
    Cname = {};
    for q = 1:length(job.sess(i).regress)
        Cnames{q} = job.sess(i).regress(q).name;
        C = [C, job.sess(i).regress(q).val(:)];
    end
    SPM.Sess(i).C.C = C;
    SPM.Sess(i).C.name = Cname;

end

% Globals
%-------------------------------------------------------------
SPM.xGX.iGXcalc = job.global;
SPM.xGX.sGXcalc = 'mean voxel value';
SPM.xGX.sGMsca  = 'session specific';

% High Pass filter
%-------------------------------------------------------------
SPM.xX.K(1).HParam = job.sess(i).hpf;

% Autocorrelation
%-------------------------------------------------------------
cVi = job.cvi;
SPM.xVi.form = cVi;

% Let SPM configure the design
%-------------------------------------------------------------
SPM = spm_fmri_spm_ui(SPM);

if ~isempty(job.mask)
    SPM.xM.VM = spm_vol(job.mask{:});
    SPM.xM.xs.Masking = [SPM.xM.xs.Masking, '+explicit mask'];
end

%-Save SPM.mat
%-----------------------------------------------------------------------
fprintf('%-40s: ','Saving SPM configuration with explicit mask')   %-#
save SPM SPM;
fprintf('%30s\n','...SPM.mat with mask saved')                     %-#

SPM = spm_spm(SPM);


fprintf('Done\n')
return
%-------------------------------------------------------------------------

%-------------------------------------------------------------------------
function vf = vfiles_stats(job)

direc = job.cd.directory{:};

if strcmpi(direc(end-1:end),'..')
    direc = direc(1:end-3);
    [direc xxx] = fileparts(direc);
elseif strcmpi(direc(end),'.')
    direc = direc(1:end-2);
end

vf = {fullfile(direc,'SPM.mat')};
