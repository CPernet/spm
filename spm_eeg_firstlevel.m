function D = spm_eeg_firstlevel(S)
% Convolution modelling for M/EEG data
% FORMAT D = spm_eeg_firstlevel(S)
%
%   S - job structure generated by spm_cfg_eeg_firstlevel
%__________________________________________________________________________
% Reference: Litvak V, Jha A, Flandin G, Friston K. Convolution models for
%            induced electromagnetic responses. Neuroimage. 2013, 64:388-98
%__________________________________________________________________________
% Copyright (C) 2013 Wellcome Trust Centre for Neuroimaging

% Vladimir Litvak
% $Id: spm_eeg_firstlevel.m 5994 2014-05-19 17:34:36Z vladimir $


SVNrev = '$Rev: 5994 $';

%-Startup
%--------------------------------------------------------------------------
spm('FnBanner', mfilename, SVNrev);
spm('FigName','M/EEG first level');

statdir = char(S.dir);
cd(statdir);

job{1}.spm.stats.fmri_design = [];
job{1}.spm.stats.fmri_design.dir            = S.dir;
job{1}.spm.stats.fmri_design.timing.units   = 'secs';
job{1}.spm.stats.fmri_design.timing.fmri_t0 = 1;
job{1}.spm.stats.fmri_design.volt           = S.volt;
job{1}.spm.stats.fmri_design.cvi            = 'none';


D        = spm_eeg_load(char(S.sess.D));

isTF     = strncmpi(D.transformtype,'TF',2);

time     = D.time;
dt       = mean(diff(time));
nt       = D.nsamples;
channels = D.selectchannels(S.channels);
nchan    = numel(channels);
nf       = D.nfrequencies;

job{1}.spm.stats.fmri_design.timing.RT  = dt;
job{1}.spm.stats.fmri_design.sess       = rmfield(S.sess, {'D', 'cond'});
job{1}.spm.stats.fmri_design.sess.hpf   = Inf;
job{1}.spm.stats.fmri_design.sess.nscan = nt;

nc = numel(S.sess.cond);

if nc == 0
    job{1}.spm.stats.fmri_design.sess.cond = S.sess.cond;
else
    for j = 1:nc
        conditionlabels = {};
        trigsample      = {};
        duration        = {};
        durationsample  = {};
        if isfield(S.sess.cond(j).define, 'event')
            S1              = [];
            S1.D            = D;
            S1.reviewtrials = 0;
            S1.save         = 0;
            S1.trialdef     = S.sess.cond(j).define.event;
            S1.timewin      = [0 0];
            [S1.trialdef(:).conditionlabel] = deal(S.sess.cond(j).name);
            
            trl                       = spm_eeg_definetrial(S1);
            trigsample{j}             = trl(:, 1);
            trig{j}                   = time(trigsample{j});
            duration{j}               = 0*trig{j};
            durationsample{j}         = 0*trig{j};
        elseif isfield(S.sess.cond(j).define, 'manual')
            if isequal(S.timing.units, 'secs')
                trig{j}         = S.sess.cond(j).define.manual.onset;
                trigsample{j}   = D.indsample(trig{j});
                duration{j}     = S.sess.cond(j).define.manual.duration;
                if isempty(duration)
                    duration{j} = 0*trig{j};
                end
                durationsample{j} = round(duration{j}*D.fsample);
            else
                trigsample{j}     = S.sess.cond(j).define.manual.onset;
                trig{j}           = time(trigsample{j});
                durationsample{j} = S.sess.cond(j).define.manual.duration;
                if isempty(durationsample)
                    durationsample{j} = 0*trig{j};
                end
                duration{j}       = durationsample{j}/D.fsample;
            end
            conditionlabels{j}    = repmat({S.sess.cond(j).name}, length(trig{j}), 1);
        else
            error('Unsupported option');
        end
        
        job{1}.spm.stats.fmri_design.sess.cond(j).name     = S.sess.cond(j).name;
        job{1}.spm.stats.fmri_design.sess.cond(j).onset    = trig{j} - D.timeonset;
        job{1}.spm.stats.fmri_design.sess.cond(j).duration = duration{j};
        job{1}.spm.stats.fmri_design.sess.cond(j).tmod     = S.sess.cond(j).tmod;
        job{1}.spm.stats.fmri_design.sess.cond(j).pmod     = S.sess.cond(j).pmod;
        job{1}.spm.stats.fmri_design.sess.cond(j).orth     = S.sess.cond(j).orth;
    end
end

eventchanind = D.indchannel('event');
if ~isempty(eventchanind)
    cond =  job{1}.spm.stats.fmri_design.sess.cond;
    job{1}.spm.stats.fmri_design.sess.cond = ...
        rmfield(cond, {'tmod', 'pmod', 'orth'});
    job{1}.spm.stats.fmri_design.timing.fmri_t    = 1;
    job{1}.spm.stats.fmri_design.bases.fir.length = dt;
    job{1}.spm.stats.fmri_design.bases.fir.order  = 1;
    
    [dummy, job] = spm_jobman('harvest', job);
    spm_run_fmri_spec(job{1}.spm.stats.fmri_design);
    
    load(fullfile(statdir, 'SPM.mat'));
    
    X = SPM.xX.X*SPM.xBF.dt;
    X = X(:, 1:(end-1));
    
    aX = any(X', 1);
    caX = cumsum(aX);
    
    if isTF
        Y = squeeze(mean(D(eventchanind, :, :), 2));
    else
        Y = D(eventchanind, :);
    end
    
    Y = Y-min(Y);
    Y = Y/max(Y);
    
    [c, lags] = xcorr(aX, Y, 500, 'coeff');
    
    [dummy, ind] = max(c);
    shiftcorr = lags(ind);
    
    if ~spm('CmdLine')
        spm_figure('GetWin','Timing check');
        clf
        subplot(2, 3, 1:3);
        plot(lags, c);
        xlim(100*[-1 1]);
        
        ntoplot = 5;
        i1 = find(caX == 1);
        i2 = find(caX == ntoplot);
        
        i3= find((caX-caX(floor(nt/2))) == 1);
        i4= find((caX-caX(floor(nt/2))) == ntoplot);
        
        i5= find((caX-caX(end)) == -ntoplot);
        i6= find((caX-caX(end)) == 0);
        
        subplot(2, 3, 4);
        plot(time(i1(1):i2(1)), Y(i1(1):i2(1)), 'k');
        hold on
        plot(time(i1(1):i2(1)), X(i1(1):i2(1), :));
        
        subplot(2, 3, 5);
        plot(time(i3(1):i4(1)), Y(i3(1):i4(1)), 'k');
        hold on
        plot(time(i3(1):i4(1)), X(i3(1):i4(1), :));
        
        subplot(2, 3, 6);
        plot(time(i5(1):i6(1)), Y(i5(1):i6(1)), 'k');
        hold on
        plot(time(i5(1):i6(1)), X(i5(1):i6(1), :));
    end
    
    delete(fullfile(statdir, 'SPM.mat'));
    job{1}.spm.stats.fmri_design.bases     = [];
    job{1}.spm.stats.fmri_design.sess.cond = cond;
else
    shiftcorr = 0;
end

for c = 1:nc
    job{1}.spm.stats.fmri_design.sess.cond(c).onset = ...
        job{1}.spm.stats.fmri_design.sess.cond(c).onset + 1e-3*S.timing.timewin(1) - shiftcorr*dt;
end



job{1}.spm.stats.fmri_design.timing.fmri_t        = S.timing.utime;
bname                                             = char(fieldnames(S.bases));

job{1}.spm.stats.fmri_design.bases                = S.bases;
job{1}.spm.stats.fmri_design.bases.(bname).length = 1e-3*diff(sort(S.timing.timewin));


[dummy, job] = spm_jobman('harvest', job);
spm_run_fmri_spec(job{1}.spm.stats.fmri_design);

clear job

load SPM.mat

X = SPM.xX.X*SPM.xBF.dt;

if S.sess.hpf
    K = [];
    K.RT     = dt;
    K.row    = SPM.Sess.row;
    K.HParam = S.sess.hpf;
else
    K = 1;
end

xX    = spm_sp('Set', spm_filter(K, X)); % filter design
if ~isfield(xX,'pX')
    xX.pX = spm_sp('x-',xX);
end

nb = size(SPM.xBF.bf, 1);
nr = size(SPM.xBF.bf, 2);

label = {};
for i = 1:numel(SPM.Sess.U)
    label = [label SPM.Sess.U(i).name];
end
ne = numel(label);

if isTF
    Dout = clone(D, spm_file(D.fname, 'path', statdir, 'prefix', S.prefix), [nchan nf nb ne]);
else
    Dout = clone(D, spm_file(D.fname, 'path', statdir, 'prefix', S.prefix), [nchan nb ne]);
end

Dout = fsample(Dout, 1/dt);
Dout = timeonset(Dout, 1e-3*S.timing.timewin(1));
Dout = chanlabels(Dout, ':', D.chanlabels(channels));
Dout = conditions(Dout, ':', label);
Dout = type(Dout, 'evoked');


spm_progress_bar('Init', nchan, 'channels done');
if nchan > 100, Ibar = floor(linspace(1, nchan, 100));
else Ibar = 1:nchan; end
for c = 1:nchan
    
    W = ones(nt, 1);
    W(D.badsamples(channels(c), ':', 1)) = exp(-256);
    W = spdiags(W, 0, nt, nt);
    
    axX    = spm_sp('Set', spm_filter(K, W*X));
    if ~isfield(axX,'pX')
        axX.pX = spm_sp('x-',axX);
    end
    
    Y = reshape(D(channels(c), :, :, :), nf, nt);
    
    Y = spm_filter(K, W*Y');
    
    B = axX.pX*Y;
    
    for i = 1:ne
        xY = SPM.xBF.bf*B((i-1)*nr+(1:nr), :);
        if isTF
            Dout(c, :, :, i) = shiftdim(xY', -1);
        else
            Dout(c, :, i) = xY';
        end
    end
    
    if ismember(c, Ibar), spm_progress_bar('Set', c); end
end

spm_progress_bar('Clear');

D = Dout;
%-Save
%--------------------------------------------------------------------------
save(D);
