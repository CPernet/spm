function spm_realign(P)
% image realignment routine
% FORMAT spm_realign(P)
% P - matrix of filenames {one string per row}
%____________________________________________________________________________
%
% spm_realign realigns a series of scans or images whose filenames
% are in the input matrix (P). The realignment uses explicit and unique
% least squares solutions and partial derivatives of the image process
% with respect to the spatial transformations constituting a rigid-
% body transformation.  The spatially realigned images are written to
% the orginal subdirectory with the same filename but prefixed with a
% 'r'.
%
% The average of all the realigned scans is written to mean*.img.  This
% image may be useful in PET-MRI co-registration
%
% To avoid artifactual movement-related variance the realigned set of images
% are internally masked, within the set (i.e. if any image has a zero value at
% a voxel than all images have zero values at that voxel).  Zero values
% occur when regions 'outside' the image are moved 'inside' the image during
% realignment.
%
%__________________________________________________________________________
% %W% %E%


%----------------------------------------------------------------------------
global PRINTSTR

% set up file identifiers and check image and voxel sizes are consistent
%----------------------------------------------------------------------------
V     = zeros(12,size(P,1));
for i = 1:size(P,1)
	V(:,i) = spm_map(P(i,:)); end

if ~(all(all(~diff(V([1:6],:)'))))
	error('images are not compatible'); end


% center, bounding box and margins
%----------------------------------------------------------------------------
bb    = spm_bb(P(1,:));					% bb = bounding box
sb    = diff(bb);					% size of bb


% compute matrices
% dQ  = 6 ortholinear transformation parameters
%----------------------------------------------------------------------------
C     = spm_matrix([-mean(bb) 0 0 0 1 1 1]);		% center of bb
D     = spm_matrix([0 0 0 0 0 0 V(4:6,1)']);		% voxel anisotropy 
C     = D*C;						% combine
a     = pi/180;						% dQ (rotation) radians
b     = 1;						% dQ (translation) mm
dQ    = [b 0 0 0 0 0;					% unit transformations
 	 0 b 0 0 0 0;
	 0 0 b 0 0 0;
         0 0 0 a 0 0;
         0 0 0 0 a 0;
         0 0 0 0 0 a];


% define height of transverse slices (S) used in subsampling the volume
%----------------------------------------------------------------------------
S     = linspace((bb(1,3) + 8/V(6)),(bb(2,3) - 8/V(6)),8);	% transverse
Q     = zeros(size(P,1),size(dQ,1));			% initial estimate
h     = 3;						% number of recursions
M     = sb(1);						% rows per slice
N     = sb(2);						% columns per slice
n     = M*N;						% voxels per slice
FWHM  = [8/V(4) 8/V(5)];
						% in plane smoothing
if V(3,1) == 1; dQ = dQ([1 2 6],:); end			% 3 params for slices
if sb(3) == 0; S = 1; end				% 1 section for slices

% compute X (the reference image) and dX/dQ (the effects of moving X)
%----------------------------------------------------------------------------
X     = zeros(n*length(S),1);
Y     = zeros(n*length(S),1);
dXdQ  = zeros(n*length(S),size(dQ,1));
for i = 1:length(S)
	B     = spm_matrix([-bb(1,1) -bb(1,2) -S(i) 0 0 0 1 1 1]);
	x     = spm_slice_vol(V(:,1),inv(B),[M N],1);
	x     = spm_conv(x,FWHM(1),FWHM(2));
  	X([1:n] + (i - 1)*n) = x(:);
        for j = 1:size(dQ,1);
		A      = spm_matrix(dQ(j,:));
		d      = spm_slice_vol(V(:,1),inv(B*inv(C)*A*C),[M N],1);
		d      = spm_conv(d,FWHM(1),FWHM(2));
		dX     = d - x;
		dXdQ(([1:n] + (i - 1)*n),j) = dX(:);
	end

end


% least squares solution for Q the movements where:
% Y = X + dX/dQ.Q  => Q = [-dX/dQ Y]\X
% The estimate is repeated iteratively h times and the estimates of Q
% are cumulated arithmetically (an aproximation but good enough)
%---------------------------------------------------------------------------
for k = 2:(size(P,1))
    for i = 1:h;
  	for j = 1:length(S)
		B      = spm_matrix([-bb(1,1) -bb(1,2) -S(j) 0 0 0 1 1 1]);
		A      = spm_matrix(Q(k,:));
		y      = spm_slice_vol(V(:,k),inv(B*inv(C)*A*C),[M N],1);
		y      = spm_conv(y,FWHM(1),FWHM(2));
		Y(([1:n] + (j - 1)*n)) = y(:);
  	end
 	q      = [-dXdQ Y]\X;
	Q(k,:) = Q(k,:) - q(1:size(dQ,1))'*dQ;
    end    
end



% open output file headers and delete existing files (prefixed with a 'r')
%--------------------------------------------------------------------------
U     = P;
for i = 1:size(P,1)
        p      = P(i,:);
        p      = p(p ~= ' ');
        q      = max([find(p == '/') 0]);
        q      = [p(1:q) 'r' p((q + 1):length(p))];
	U(i,[1:length(q)]) = q;
	fid    = fopen(q,'r');
	if fid > 0; fclose(fid); eval(['delete ' q]) ; end
	
	[DIM VOX SCALE TYPE OFFSET ORIGIN] = spm_hread(p);
	spm_hwrite(q,DIM,VOX,SCALE,TYPE,0,ORIGIN,'spm - realigned');
end

% write the realigned images to output files 
%---------------------------------------------------------------------------
for j = 1:DIM(3)
	B     = spm_matrix([0 0 -j 0 0 0 1 1 1]);
	D     = ones(DIM(1),DIM(2));

	% first pass over images to create a mask
	%------------------------------------------------------------------
	for i = 1:size(P,1)
		A  = spm_matrix(Q(i,:));
		d  = spm_slice_vol(V(:,i),inv(B*inv(C)*A*C),DIM(1:2),1);
		D  = D.*(~(~d));
	end

	% 2nd pass to apply mask and write
	%------------------------------------------------------------------
	for i = 1:size(P,1)
		A   = spm_matrix(Q(i,:));
		d   = spm_slice_vol(V(:,i),inv(B*inv(C)*A*C),DIM(1:2),1);
		d   = d.*D/V(7,i);
		if TYPE <= 8; d = round(d); end
        	q   = U(i,:);
        	q   = q(q ~= ' ');
  		fid = fopen(q,'a');
		fwrite(fid,d,spm_type(TYPE));
		fclose(fid);
	end
end

% write mean image
%---------------------------------------------------------------------------
p      = P(1,:);
p      = p(p ~= ' ');
q      = max([find(p == '/') 0]);
q      = [p(1:q) 'mean' p((q + 1):length(p))];

spm_mean(prod(DIM),TYPE,q,U);
spm_hwrite(q,DIM,VOX,SCALE,TYPE,0,ORIGIN,'spm - mean image');


% unmap and close files
%---------------------------------------------------------------------------
for i = 1:size(P,1); spm_unmap_vol(V(:,i)); end
fclose('all');


% display results
% translation and rotation over time series
%---------------------------------------------------------------------------
figure(3); spm_clf; subplot(3,1,1); axis off

title('Image realignment','FontSize',16,'FontWeight','Bold')
x     = -0.1;
y     =  0.9;
for i = 1:min([size(P,1) 12])
	text(x,y,[sprintf('%-4.0f',i) P(i,:)],'FontSize',10);
	y = y - 0.08;
end
if size(P,1) > 12
	text(x,y,'................ etc','FontSize',10); end


subplot(3,1,2)
plot(Q(:,1:3))
s = ['x translation';'y translation';'z translation'];
text([2 2 2], Q(2, 1:3), s, 'Fontsize',10)
title('translation','FontSize',16,'FontWeight','Bold')
xlabel('image')
ylabel('mm')
grid 


subplot(3,1,3)
plot(Q(:,4:6)*180/pi)
s = ['pitch';'roll ';'yaw  '];
text([2 2 2], Q(2, 4:6)*180/pi, s, 'Fontsize',10)
title('rotation','FontSize',16,'FontWeight','Bold')
xlabel('image')
ylabel('degrees')
grid

% print realigment parameters and figure 2 attributes
%----------------------------------------------------------------------
spm_print
figure(2); clf
set(2,'Name','','Pointer','Arrow');
